#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  Turn,           sensorTouch)
#pragma config(Sensor, I2C_1,  motorI2C,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorBackRight, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motorSteer,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           motorLinear,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          motorBackLeft, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool Turnp;

enum control{Forward, Left, Right};
enum control direction;
enum control state;

enum orientation {Down, Up};
enum orientation linear;

int steerSpeed = 20;
int motorStop = 0;
int speed = 25;

bool isPushed(){
	if(SensorValue(Turn) && !Turnp)
	{
		Turnp = true;
		return true;
	}

	return false;
}

void steerDirect(){
	if(state == Left || state == Right){
			if(state == Left){
				motor[motorSteer] = steerSpeed;
			} else {
				motor[motorSteer] = -steerSpeed;
			}
			waitUntil(abs(SensorValue[motorI2C]) <= 100);
			motor[motorSteer] = motorStop;
			state = Forward;
	}else {
		if(direction == Right){
			motor[motorSteer] = steerSpeed;
			waitUntil(SensorValue[motorI2C] <= -700);
			motor[motorSteer] = motorStop;
			state = Right;
		}else {
			motor[motorSteer] = -steerSpeed;
			waitUntil(SensorValue[motorI2C] >= 700);
			motor[motorSteer] = motorStop;
			state = Right;
		}
	}
}

void linearMotion(){
	if(linear == Up){
		motor[motorLinear] = speed;
		wait10Msec(100);
		motor[motorLinear] = motorStop;
		linear = Down;
		} else {
		motor[motorLinear] = -(speed-8);
		wait10Msec(120);
		motor[motorLinear] = motorStop;
		linear = Up;
	}
}

void forward(){
	motor[motorBackRight] = speed;
	motor[motorBackLeft] = speed;
	wait10Msec(300);
	motor[motorBackRight] = motorStop;
	motor[motorBackLeft] = motorStop;
}

void backward(){
	motor[motorBackRight] = -speed;
	motor[motorBackLeft] = -speed;
	wait10Msec(300);
	motor[motorBackRight] = motorStop;
	motor[motorBackLeft] = motorStop;
}

void test(){
	direction = Left;
	steerDirect();

	motor[motorBackRight] = 25;
	motor[motorBackLeft] = -20;
	wait10Msec(300);
	motor[motorBackRight] = motorStop;
	motor[motorBackLeft] = motorStop;
	steerDirect();
}

task main(){
	state = Forward;
	direction = Forward;
	SensorValue[motorI2C] = 0;

	while(true){
		if(isPushed()){
			if(Turnp == true){
				test();
				//steerDirect();
				//forward();
				//backward();
				//linearMotion();
				Turnp = false;
			}
		}

	}

}
