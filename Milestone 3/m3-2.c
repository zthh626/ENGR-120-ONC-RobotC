#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    front1i,        sensorReflection)
#pragma config(Sensor, in2,    front2i,        sensorReflection)
#pragma config(Sensor, in3,    righti,         sensorReflection)
#pragma config(Sensor, in4,    backi,          sensorReflection)
#pragma config(Sensor, in5,    lefti,          sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  linI2C,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           right,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           linear,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int threshold = 170;
const int meter = 6;

bool button1p;
bool button2p;

enum control{Forward, Left, Right};
enum control direction;

enum orientation {Down, Up};
enum orientation linearO;

int mstop = 0;
int speed = 25;
int linSpeed = 15;

bool isPushed(){
	if(SensorValue(button1) && !button1p)
	{
		button1p = true;
		return true;
		} else if(SensorValue(button2) && !button2p){
		button2p = true;
		return true;
	}

	return false;
}

void forward(){
	motor[left] = speed;
	motor[right] = speed;
	wait10Msec(300);
	motor[left] = mstop;
	motor[right] = mstop;
}

void backward(){
	motor[left] = -speed;
	motor[right] = -speed;
	wait10Msec(150);
	motor[left] = mstop;
	motor[right] = mstop;
}

void turn(){
	if(direction == Right){
		motor[right] = -speed*2;
		motor[left] = speed*2;
		}else {
		motor[right] = speed*2;
		motor[left] = -speed*2;
	}
}

void linearMotion(){
	if(linearO == Up){
		motor[linear] = linSpeed;
		waitUntil(SensorValue[linI2C] >= 20);
		motor[linear] = mstop;
		linearO = Down;
		} else {
		motor[linear] = -linSpeed;
		waitUntil(SensorValue[linI2C] <= -100);
		motor[linear] = mstop;
		linearO = Up;
	}
}

void test(){
	forward();
	linearMotion();
	backward();
	direction = Right;
	turn();
	forward();
	direction = Forward;
	linearMotion();
}

bool detect(){
	if(SensorValue[sonar] <= meter){
		return true;
	}
	return false;
}

bool wallDetect(){
	if(SensorValue[sonar] <= meter + 10){
		return true;
	}
	return false;
}

void mile(){
	while(!(detect() && abs(SensorValue[front1i] - SensorValue[front2i]) <= 70)){
		direction = Forward;
		motor[left] = speed;
		motor[right] = speed;
		if(SensorValue[righti] <= threshold){
			direction = Right;
			} else if(SensorValue[backi] <= threshold){
			direction = Right;
			} else if(SensorValue[lefti] <= threshold){
			direction = Left;
			} else if(SensorValue[front2i] <= threshold && SensorValue[righti] <= threshold){
			direction = Right;
			} else if(SensorValue[front1i] <= threshold && SensorValue[lefti] <= threshold){
			direction = Left;
			} else if(SensorValue[backi] <= threshold && SensorValue[lefti] <= threshold){
			direction = Left;
			} else if(SensorValue[backi] <= threshold && SensorValue[righti] <= threshold){
			direction = Right;
		}
		while(!(SensorValue[righti] >= threshold && SensorValue[backi] >= threshold && SensorValue[lefti] >= threshold)){
			turn();
			wait10Msec(10);
		}
	}
	motor[left] = mstop;
	motor[right] = mstop;
}

task main(){
	direction = Forward;
	linearO = Down;
	SensorValue[linI2C] = 0;

	while(true){
		if(isPushed()){
			if(button1p == true){
				//test();
				mile();
				button1p = button2p = false;
			}
			else if(button2p == true){
				linearMotion();
				button1p = button2p = false;
			}
		}
	}
}
