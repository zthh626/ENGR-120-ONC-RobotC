#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    front1i,        sensorReflection)
#pragma config(Sensor, in2,    front2i,        sensorReflection)
#pragma config(Sensor, in3,    righti,         sensorNone)
#pragma config(Sensor, in4,    backi,          sensorReflection)
#pragma config(Sensor, in5,    lefti,          sensorNone)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  linI2C,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           right,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           linear,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int threshold = 140;
const int threshold2 = 200;
const int meter = 6;

int frontlight1;
int frontlight2;
int backlight;

bool button1p;
bool button2p;

enum control{Forward, Left, Right};
enum control direction;

enum orientation {Down, Up};
enum orientation linearO;

int mstop = 0;
int speed = 25;
int linSpeed = 15;

bool isPushed(){
	if(SensorValue(button1) && !button1p)
	{
		button1p = true;
		return true;
		} else if(SensorValue(button2) && !button2p){
		button2p = true;
		return true;
	}

	return false;
}

void forward(){
	motor[left] = speed;
	motor[right] = speed;
	wait10Msec(300);
	motor[left] = mstop;
	motor[right] = mstop;
}

void backward(){
	motor[left] = -speed;
	motor[right] = -speed;
	wait10Msec(150);
	motor[left] = mstop;
	motor[right] = mstop;
}

void turn(){
	if(direction == Right){
		motor[right] = -speed*2;
		motor[left] = speed*2;
		}else {
		motor[right] = speed*2;
		motor[left] = -speed*2;
	}
}

void linearMotion(){
	if(linearO == Up){
		motor[linear] = linSpeed;
		waitUntil(SensorValue[linI2C] >= 20);
		motor[linear] = mstop;
		linearO = Down;
		} else {
		motor[linear] = -linSpeed;
		waitUntil(SensorValue[linI2C] <= -100);
		motor[linear] = mstop;
		linearO = Up;
	}
}

void test(){
	forward();
	linearMotion();
	backward();
	direction = Right;
	turn();
	forward();
	direction = Forward;
	linearMotion();
}

bool detect(){
	if(SensorValue[sonar] <= meter){
		return true;
	}
	return false;
}

bool wallDetect(){
	if(SensorValue[sonar] <= meter + 10){
		return true;
	}
	return false;
}

int monitorLight(String name)
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[name];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}

void mile(){
	motor[left] = speed;
	motor[right] = speed;
	frontlight1 = monitorLight(front1i);
	while(!(detect() && SensorValue[front1i] <= threshold && SensorValue[front2i] <= threshold)){
		if(SensorValue[backi] <= threshold2){
			direction = Right;
		} else {
			if((SensorValue[front1i] - SensorValue[front2i]) > 0 ){
			direction = Right;
			} else {
			direction = Left;
			}
		}
		wait1Msec(100);
		while(){
			turn();
		}
		motor[left] = speed;
		motor[right] = speed;
	}
	motor[left] = mstop;
	motor[right] = mstop;
}

task main(){
	direction = Forward;
	linearO = Down;
	SensorValue[linI2C] = 0;

	while(true){
		if(isPushed()){
			if(button1p == true){
				//test();
				mile();
				button1p = button2p = false;
			}
			else if(button2p == true){
				linearMotion();
				button1p = button2p = false;
			}
		}
	}
}
