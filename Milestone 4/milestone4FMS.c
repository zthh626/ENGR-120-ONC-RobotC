#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    iFLeft,         sensorReflection)
#pragma config(Sensor, in2,    iFRight,        sensorReflection)
#pragma config(Sensor, dgtl6,  ir,             sensorDigitalOut)
#pragma config(Sensor, dgtl8,  button2,        sensorTouch)
#pragma config(Sensor, dgtl9,  button1,        sensorTouch)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  linI2C,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           right,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           linear,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//flag to see if connection is finished
bool complete = false;

//state the robot is in
enum RobotState {
	Turn = 0,
	StraightForward,
	WallDetect,
	Disconnection,
	CompleteState
};

enum RobotState state;

//Range between two IR values that is acceptable used in determineTurn()
int delta;

//values of IR sensors that get updated periodically
int vFLeft;
int vFRight;

//booleans for if button1 and button2 if they get pushed
bool button1p;
bool button2p;

//enumeration for directions to turn
enum control{Forward, Left, Right};
enum control direction;

//enumeration for linear motion mechanism to move up or down
enum orientation {Down, Up};
enum orientation linearO;

//distance for detect() and wallDetect(), when distance gets less than this number
//	will return false in function
int distanceConnect = 6;
int distanceWall = 20;

//distance for
int distanceCorrect = 40;

//minlevel for IR sensors in monitorFunction(),
int minLevelF = 600;

//threshold for IR sensors
int frontThreshold = 200;

//values for motor
//stoping value
int mstop = 0;
//linear motion mechanism motor speed
int linSpeed = 15;
//default speed for moving forward
int speed = 35;
//turning speed
int turnSpeed  = 25;

//if linearO is UP or Down will move mechanism up or down
//	should go down first and then go up
void linearMotion(){
	if(linearO == Up){
		motor[linear] = linSpeed;
		//moves motor to the top position to make room for cable
		waitUntil(SensorValue[linI2C] <= -150);
		motor[linear] = mstop;
		linearO = Down;
		} else {
		motor[linear] = -linSpeed;
		//closes the linear motion mechanism
		waitUntil(SensorValue[linI2C] >= 0);
		motor[linear] = mstop;
		linearO = Up;
	}
}

//checks whether the buttons are pushed
bool isPushed(){
	if(SensorValue(button1) && !button1p)
	{
		button1p = true;
		return true;
		} else if(SensorValue(button2) && !button2p){
		button2p = true;
		return true;
	}

	return false;
}

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
// Every time this function is called updates values for vFLeft and vFRight
void monitorLight(){
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.

	//min, max, dif level for iFLeft sensor
	static int minLevelIR1 = minLevelF;
	static int maxLevelIR1 = 0;
	static int diffLevelIR1 = 0;

	//min, max, dif level for iFRight sensor
	static int minLevelIR2 = minLevelF;
	static int maxLevelIR2 = 0;
	static int diffLevelIR2 = 0;

	//gets value for each sensor
	int lightLevel1 = SensorValue[iFLeft];
	int lightLevel2 = SensorValue[iFRight];

	//determines value for sensor each every 100 ms
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		// for iFRight
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs for iFRight
		maxLevelIR1 = 0;
		minLevelIR1 = minLevelF;

		// 100 msecs have elapsed.  Compute delta of light level.
		// for iFLeft
		diffLevelIR2 = maxLevelIR2 - minLevelIR2;

		// Reset calculation for next 100 msecs for iFLeft
		maxLevelIR2 = 0;
		minLevelIR2 = minLevelF;

		clearTimer(T1);
		} else {
		// Check for new minimum/maximum light levels for each sensor
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}

		if ( lightLevel2 < minLevelIR2 ) {
			minLevelIR2 = lightLevel2;
			} else if ( lightLevel2 > maxLevelIR2 ) {
			maxLevelIR2 = lightLevel2;
		}
	}

	//updates each value
	vFLeft = diffLevelIR1;
	vFRight = diffLevelIR2;
}

//turns left or right
//	direction is determined before function is called
//	turns by rotating one wheel one direction and the other the
//	opposite ways
void turn(){
	if(direction == Right){
		//-10 for warped gear, warped gear spins slower
		motor[right] = -turnSpeed -10;
		motor[left] = turnSpeed;
		}else if(direction == Left){
		motor[right] = turnSpeed;
		motor[left] = -turnSpeed;
	}
}

//returns true if robot is less than distanceConnect
//	false otherwise
bool detect(){
	if(SensorValue[sonar] <= distanceConnect){
		return true;
	}
	return false;
}

//returns true if robot is less than distanceWall
//	false otherwise
bool detectWall(){
	if(SensorValue[sonar] <= distanceWall){
		return true;
	}
	return false;
}

//determines direction and returns true if only sensors in the front
//	break threshold and returns false for all cases
bool determineTurn(){

	//if only front sensors break threshold, direction = forward and returns true
	//	otherwise returns false and sets direction to right
	if(vFRight > frontThreshold && vFLeft > frontThreshold){
		//checks if the robot is within a certain distance of the robot
		// depending on the distane delta value is changed, the higher it is,
		//	the less sensative the correcting of the robot is, this allows it to
		//	detect the beacon from far distances and be more accurate the closer it is
		if(SensorValue[sonar] < distanceCorrect){
			delta = 20;
			}else {
			delta = 100;
		}
		//if the difference between the sensors is less than delta, direction is forward
		if(abs(vFRight - vFLeft) < delta) direction = Forward;
		//if the robot is more on the left side, then direction is set left
		else if(vFRight - vFLeft < 0) direction = Left;
		//if the robot is more on the right side, then direction is set right
		else if(vFRight - vFLeft > 0) direction = Right;
		else direction = Forward;
		return true;
	}
	//default direction is false, (when both IR don't break threshold)
	direction = Right;

	//for every case except front sensors break threshold it returns false
	return false;
}

//if a wall is detected returns true
//	else returns false
bool wallDetection(){
	//checks detectWall, if it returns true then robot is close to wall,
	// and checks if determineTurn(), determineTurn() returns false when both sensors
	//		do not break threshold
	if(detectWall() && !determineTurn()){
		state = WallDetect;
		return true;
	}
	return false;
}

//calls the monitorLight() function and updates values constantly in a task
task updateIRValues(){
	while(true){
		monitorLight();
	}
}

task main(){

	//starts task that up updates IR values
	startTask(updateIRValues);

	//initializes enum values and I2c
	direction = Forward;
	linearO = Up;
	SensorValue[linI2C] = 0;

	while(true){
		if(isPushed()){
			if(button1p == true){
				while(!complete){

					determineTurn();

					switch(state){

					case StraightForward:
						if(!detect()){
							if(WallDetection()){
								state = WallDetect;
								break;
							}

							if(direction == Forward){
								motor[right] = speed;
								motor[left] = speed;
							}else state = Turn;
						} else state = Disconnection;
						break;

					case Turn:
						if(!detect()){
							if(WallDetection()){
								state = WallDetect;
								break;
							}

							if(direction != Forward) turn();
							else if(direction == Forward) state = StraightForward;
						}else state = Disconnection;
						break;

					case WallDetect:
						motor[left] = -speed;
						motor[right] = -speed;
						wait10Msec(100);
						//turns right
						direction = Right;
						turn();
						wait10Msec(200);
						//stops motors
						motor[left] = mstop;
						motor[right] = mstop;
						direction = Forward;

						state = Turn;

						break;

					case Disconnection:
						//lowers linearmotion mechanism
						linearMotion();
						//reverses robot for a certain amount of time
						motor[left] = -speed;
						motor[right] = -speed;
						wait10Msec(200);
						//sets direction to turn right and turns
						direction = Left;
						turn();
						//waits and then stops motors
						wait10Msec(300);
						direction = Forward;
						int counter = 0;
						while(counter < 200){
							if(!detectWall()){
								motor[left] = speed;
								motor[right] = speed;
								}else {
								motor[left] = mstop;
								motor[right] = mstop;
							}
							wait1Msec(10);
							counter += 1;
						}
						//waits and then stops motor
						motor[left] = mstop;
						motor[right] = mstop;
						linearMotion();

						state = CompleteState;
						break;

					case CompleteState:
						complete = true;
						break;
					}

				}

				complete = false;

				button1p = button2p = false;
			}
			else if(button2p == true){
				//motor[linear] = -linSpeed;
				linearMotion();

				button1p = button2p = false;
			}
		}
	}
}
