#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    iFLeft,         sensorReflection)
#pragma config(Sensor, in2,    iFRight,        sensorReflection)
#pragma config(Sensor, in3,    iRight,         sensorReflection)
#pragma config(Sensor, in4,    iBack,          sensorReflection)
#pragma config(Sensor, in5,    iLeft,          sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  ir,             sensorDigitalOut)
#pragma config(Sensor, I2C_1,  linI2C,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           right,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           linear,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//values of IR sensors that get updated periodically
int vFLeft;
int vFRight;
int vLeft;
int vRight;
int vBack;

//booleans for if button1 and button2 if they get pushed
bool button1p;
bool button2p;

//enumeration for directions to turn
enum control{Forward, Left, Right};
enum control direction;

//enumeration for linear motion mechanism to move up or down
enum orientation {Down, Up};
enum orientation linearO;

//distance for wallDetect(), when distance gets less than this number
//	will return false in function
int distanceConnect = 6;

//minlevel for IR sensors in monitorFunction(),
int minLevel = 350;

//values for motor
//stoping value
int mstop = 0;
//linear motion mechanism motor speed
int linSpeed = 15;
//default speed for moving forward
int speed = 30;
//turning speed
int turnSpeed  = 40;

//threshold for IR sensors
int threshold = 160;

//if linearO is UP or Down will move mechanism up or down
//	should go down first and then go up
void linearMotion(){
	if(linearO == Up){
		//moves motor at linSpeed
		motor[linear] = linSpeed;
		//waits until I2C value is more than 20
		waitUntil(SensorValue[linI2C] >= 20);
		//stops motor
		motor[linear] = mstop;
		//sets to opposite direction
		linearO = Down;
		} else {
		//moves motor at opposite speed
		motor[linear] = -linSpeed;
		//waits until I2C is less than -100
		waitUntil(SensorValue[linI2C] <= -100);
		//stop motor
		motor[linear] = mstop;
		//sets to opposite direction
		linearO = Up;
	}
}

bool isPushed(){
	if(SensorValue(button1) && !button1p)
	{
		button1p = true;
		return true;
		} else if(SensorValue(button2) && !button2p){
		button2p = true;
		return true;
	}

	return false;
}

//updates values of each ir sensor every pulse of the beacon detected
void monitorLight(){
	//min, max, dif level for iFLeft sensor
	static int minLevelIR1 = minLevel;
	static int maxLevelIR1 = 0;
	static int diffLevelIR1 = 0;

	//min, max, dif level for iFRight sensor
	static int minLevelIR2 = minLevel;
	static int maxLevelIR2 = 0;
	static int diffLevelIR2 = 0;

	//min, max, dif level for iRight sensor
	static int minLevelIR3 = minLevel;
	static int maxLevelIR3 = 0;
	static int diffLevelIR3 = 0;

	//min, max, dif level for iBack sensor
	static int minLevelIR4 = minLevel;
	static int maxLevelIR4 = 0;
	static int diffLevelIR4 = 0;

	//min, max, dif level for ileft sensor
	static int minLevelIR5 = minLevel;
	static int maxLevelIR5 = 0;
	static int diffLevelIR5 = 0;

	//gets value for each sensor
	int lightLevel1 = SensorValue[iFLeft];
	int lightLevel2 = SensorValue[iFRight];
	int lightLevel3 = SensorValue[iRight];
	int lightLevel4 = SensorValue[iBack];
	int lightLevel5 = SensorValue[iLeft];

	//determines value for sensor each every 100 ms
	if ( time1[T1] > 100 )  {
		//determines difflevel for each sensor, sets maxlevel to 0,
		//	and minlevel to default level
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;
		maxLevelIR1 = 0;
		minLevelIR1 = minLevel;

		diffLevelIR2 = maxLevelIR2 - minLevelIR2;
		maxLevelIR2 = 0;
		minLevelIR2 = minLevel;

		diffLevelIR3 = maxLevelIR3 - minLevelIR3;
		maxLevelIR3 = 0;
		minLevelIR3 = minLevel;

		diffLevelIR4 = maxLevelIR4 - minLevelIR4;
		maxLevelIR4 = 0;
		minLevelIR4 = minLevel;

		diffLevelIR5 = maxLevelIR5 - minLevelIR5;
		maxLevelIR5 = 0;
		minLevelIR5 = minLevel;

		//clears timer
		clearTimer(T1);
		} else {
		//if lightlevel of each sensor is less than minlevel
		//	then minlevel will equal lightlevel
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			//and then if lightlevel is greater than maxlevel
			//	maxlevel will  equal lightlevel
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
		if ( lightLevel2 < minLevelIR2 ) {
			minLevelIR2 = lightLevel2;
			} else if ( lightLevel2 > maxLevelIR2 ) {
			maxLevelIR2 = lightLevel2;
		}
		if ( lightLevel3 < minLevelIR3 ) {
			minLevelIR3 = lightLevel3;
			} else if ( lightLevel3 > maxLevelIR3 ) {
			maxLevelIR3 = lightLevel3;
		}
		if ( lightLevel4 < minLevelIR4 ) {
			minLevelIR4 = lightLevel4;
			} else if ( lightLevel4 > maxLevelIR4 ) {
			maxLevelIR4 = lightLevel4;
		}
		if ( lightLevel5 < minLevelIR5 ) {
			minLevelIR5 = lightLevel5;
			} else if ( lightLevel5 > maxLevelIR5 ) {
			maxLevelIR5 = lightLevel5;
		}
	}

	//updates each value
	vFLeft = diffLevelIR1;
	vFRight = diffLevelIR2;
	vRight = diffLevelIR3;
	vBack = diffLevelIR4;
	vLeft = diffLevelIR5;
}

//returns true if robot is less than distanceConnect
//	false otherwise
bool detect(){
	if(SensorValue[sonar] <= distanceConnect){
		return true;
	}
	return false;
}

//turns left or right
//	direction is determined before function is called
//	turns by rotating one wheel one direction and the other the
//	opposite ways
void turn(){
	if(direction == Right){
		motor[right] = -turnSpeed;
		motor[left] = turnSpeed;
	}else if(direction == Left){
		motor[right] = turnSpeed;
		motor[left] = -turnSpeed;
	}
}

//determines direction and returns true if only sensors in the front
//	break threshold and returns false for all cases
bool determineTurn(){
	//if only front sensors break threshold, direction = forward and returns true
	if(vFRight > threshold && vFLeft > threshold){
		direction = Forward;
		return true;
		//if vRight or vLeft breaks threshold
	} else if(vRight > threshold || vLeft > threshold){
		//if vRight  breaks threshold it turns rigt
		if(vRight > threshold){
			direction = Right;
		}
		//if vLeft breaks theshold turns left
		if(vLeft > threshold){
			direction = Left;
		}
		//else is the back sensor case, turns right
	}else {
		direction = Right;
	}

	//for every case except front sensors break threshold it returns false
	return false;
}

//will be called at button press, will make connection.
//	a while loop will run until determineTurn() returns true, that's when
//	both front sensors are facing beacon, and detect() returns true.
//	detect() returns true when it has reached the appropriate connection distance.
//	if the direction is forward but detect() is still false, the robot will go straight.
void changeDirection(){
	while(!determineTurn() && !detect()){
		turn();
		if(direction == forward){
			motor[right] = speed;
			motor[left] = speed;
		}
	}
}

task ledHz(){
	while(true){
		wait10Msec(10);
		SensorValue[ir] = 1;
		wait10Msec(10);
		SensorValue[ir] = 0;
	}
}

//calls the monitorLight() function
task updateIRValues(){
	while(true){
		monitorLight();
	}
}

task main(){

	startTask(ledHz);
	startTask(updateIRValues);

	direction = Forward;
	linearO = Down;
	SensorValue[linI2C] = 0;

	while(true){
		if(isPushed()){
			if(button1p == true){
				button1p = button2p = false;
			}
			else if(button2p == true){
				button1p = button2p = false;
			}
		}
	}
}
