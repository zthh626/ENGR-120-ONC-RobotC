#pragma config(Sensor, in1,    motorSteer_angle, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Motor,  port1,           motorBackRight, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motorBackLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorSteer,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1p;
bool button2p;

enum turn {Forward , Left, Right};
enum turn direction;

bool isPushed(){
	if(SensorValue(button1) && !button1p)
  {
    button1p = true;
    return true;
  }

  if(SensorValue(button2) && !button2p)
  {
    button2p = true;
    return true;
  }
  return false;
}

void straightOne(){
	int count = 0;
	while(count < 3){
		button1p = false;
		button2p = false;
		motor[motorBackLeft] = 50;
		motor[motorBackRight] = 50;

		count++;
		wait1Msec(1000);
	}
}

void turner(){
	if(direction == Left){
		while(SensorValue[motorSteer_angle] <= 1500){
			motor[motorSteer] = 30;
		}
		motor[motorSteer] = 0;

		motor[motorBackLeft] = 25;
		motor[motorBackRight] = 50;
		wait1Msec(1000);

		while(SensorValue[motorSteer_angle] >= 1500){
			motor[motorSteer] = -30;
		}
		motor[motorSteer] = 0;
	}else if(direction == Right){
		while(SensorValue[motorSteer_angle] >= 1500){
			motor[motorSteer] = -30;
		}
		motor[motorSteer] = 0;

		motor[motorBackLeft] = 25;
		motor[motorBackRight] = 50;
		wait1Msec(1000);

		while(SensorValue[motorSteer_angle] <= 1500){
			motor[motorSteer] = 30;
		}
		motor[motorSteer] = 0;
	}
}

task main(){
	button1p = button2p = false;
	direction = Forward;

	while(true){
		if(isPushed()){
			if(button1p == true){
				straightOne();
				motor[motorBackLeft] = 0;
				motor[motorBackRight] = 0;
			}else if(button2p == true){
				direction = Right;
				turner();
				direction = Forward;
				button1p = button2p = false;
			}
		}
	}
}
